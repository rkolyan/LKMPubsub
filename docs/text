Чтение сообщения
Есть структура sub
1. Получаем pos из sub (изменять pos у sub может только сам sub);
2. Узнаем номер pos (он может менятся у pos во время записи, например, когда первое сообщение удаляется, pos смещается на следующее)
3. По номеру происходит чтение из буфера (оно может затираться, то есть может происходить чтение во время записи)
---Если прочиталось--
4. Отписываем подпичика от позиции (уменьшаем её счётчик)
5. Если счётчик = 0
<----Между этими операцими какой-то подписчик мог подписаться, поэтому нужно поставить между ними защиту,
например
spin_lock(lock);
if (is_position_not_used(pos)) {
	block = 1;
	pop_used_position(pos);
}
spin_unlock(lock);
if (block) {
	продолжаем удаление
}
5.1 удаляем позицию (могут возникнуть проблемы при чтении, нужно использовать synchronize_rcu и спин-лок)
5.2 Добавляем новую позицию в свободные (там можно изпользовать kmem_cache_free)
5.3 Далее идет чтение с буфера. Что можно придумать с неделимыми переменными, чтоб запись и чтение не совпадающих номеров происходили одновременно?

6. Найденный номер увеличиваем
7. Находим по новому номеру новую позицию
<---------Вот здесь может произойти то, что позиция удаляется,
решаем также, используя ранее введенный spin_lock:
block = 0
spin_lock(lock);
err = find_msg_num_pos(...)
if (!err) {
	connect_subscriber_position(sub, pos);
	block = 1;
}
spin_unlock(lock)
if (block) {
	Продолжаем
}
8.1. Если нашли то подписчик переподписывается на выбранную позицию
<----Спинлок
8.2. Если не нашли то просматриваем следующую позицию
8.2.1 Если найдена берём свободную позицию (может отдельный спинлок использовать);
8.2.2.... Короче, там добавляем новый, присоединяем
<----Спин-анлок


Отправка сообщения
1. Проверка, что буфер полон
2. Тут те же самые операции, что и в receive_message_from_node, аналогичное использование спинлок

Буфер:
Чтение:
Делаем проще
1.Спин-лок
--Обновляем значение нижней "границы блокировки" - это будет атомарная переменная
2.Спин-анлок
Чтение данного блока
сброс атомарной переменной


Запись:
Спин-лок
--Обновляем данные в buf->end, buf->begin (если потребуется), end_num, begin_num(Если потребуется)
Спин-анлок
Просматриваем нижнюю границу чтения, если она равна записываемой, то ждём окончания блока снизу
(делаем это через atomic_sub_and_test)
Возможно здесь как-то можно сделать rcu, типа, rcu указывает на следующее значение массива при обращении чтения

Если у нас неблокируемый режим записи и если свободных полей нет



if (atomic_try_cmpxchg(end, base_end, base_begin)) {
	//Ставим блок на чтение этого адреса, или проверяем
	обновляем base_begin_num
} else {
	atomic_add(block_size);
}

Запись
Итак, получаем адрес сообщения, который надо написать
spin_lock()
//Увеличиваем номер сообщения (end_num)
//Увеличиваем указатель сообщения (end)
//Если указатель сообщения превысил границу, делаем инверсию флага (что теперь конец чтения раньше начала по адресу)
//Обновляем верхний ограничитель записи
spin_unlock()

//TODO: Проверка на границы чтения (может быть до спин-лока, тогда всем операциям записи нужно будет ждать, пока прочитается значение из буфера)
//TODO: Может быть после спинлока, тогда он может быть заблокирован на пограничном мьютексе может быть?
//TODO: В случае записи следующий может быть также заблокирован, тогда указатели будут увеличены и пойдет неправильная запись
 
//Далее идёт процесс записи в блок

spin_lock()
//Заканчиваем, помечаем, что блок доступен для чтения (Как это сделать?)
//В случае, если собственое число == нижней границы, то увеличиаем нижнюю границу
spin_unlock()

//TODO: Видимо, единственное что можно сделать это мьютекс на запись, когда записывается только 

Конец


Процесс чтения:
Пусть 




Алгоритмы быстрого неблокируемого чтения из буфера 
1)Определяем номер сообщения
2)Если номер в пределе, ставим минимальный номер в порядке следования с ним и ставим блок на этот номер
(только вот как этот блок поставить?)
3)atomic_fetchadd()



В случае с буфером можно использовать atomic_inc_return(end_num), atomic_inc_return(begin_num)
atomic_fetch_inc_acquire(end)
atomic_cmpxchg_relaxed_long(atomic_t *v, old, new) Если v == old, то v = new

можно сделать так

Поток проходит
atomic_
atomic_cmp

if (atomic_try_cmpxchg(end, base_end, base_begin)) {
	//записываем в base_begin
	обновляем base_begin
} else {
	
}


atomic_inc()

atomic_inc_return(end_num);


Запись:
Выделение структуры в кеше для того, чтобы писателя
Проверка свободности следующего блока (atomic_t rbegin)
Если следующий блок несвободен (то есть это первый блок на чтение):
	Если флаг блокировки не установлен:
		//TODO: Мы блокируем все записи и ждём, пока читатель дочитает
		устанвавливаем флаг, на удаление элемента чтения (чтоб будущие читатели не могли прочитать)
		захватываем мьютекс на первую запись
		//TODO: Но что если следующий тоже будет записывать, но уже не в этот свободный элемент, а следующий?
	Иначе:
		Переход на метку End
Иначе:
	Запись в этот блок
END:
Удаление структуры писателя из кеша

Чтение:
Создание элемента для чтения
Спинлок
Сравнение текущей позиции с началом чтения
Если позиция не первая, то установка флага на чтение
Спинанлок
Добавление элемента в список читателей
Начать чтение



можно использовать wait_event_interactible(wq_head, (int)wq_head->private) в записи.
В чтении wake_up_interruptible(wq_head). Заранее можно объявить глобальную переменную, которая хранит в себе номер текущей освобожденной от чтения позиции


Запись:
Если флаг блокировки не стоит:
	Смещаем позицию end
	Если читатель читает процесс (ищем в хеш-таблице мьютекс по позиции, если он там есть)
		Заблокировать писателя (отправить в очередь работ)
	Писатель в таблицу записываемых потоков ставит блок на позицию
	Писатель записывает данные
	Писатель удаляет блок на позицию в таблице


Чтение:
Если число за рамками чтения
	Вернуть сообщение об отказе (новых данных нет)
Пока позиция заблокирована и не выходит за рамки искать свободную ячейку (можно быстренько просмотреть список писателей и сразу же перейти на следующую)
Заблокировать позицию на чтение (например минимизация счётчика свободного элемента)
Произвести чтение
В случае, если текущая позиция заблокирована, то вызвать из отложенных работ функцию записи в этот элемент


ЭТО ПРОСТАЯ ВЕРСИЯ, ГДЕ МОЖНО ТОЛЬКО 1 РАЗ ВО ВРЕМЯ!
Запись:
//Спин-лок
Если в буфере ещё есть место для записи (где-то хранятся промежутки между записываем элементом и первым в чтении)
    добавить в в конец списка новой записи о занят
Иначе
    установить ошибка = EAGAIN
спин-анлок
Если ошибка
	верни ошибку
запись в ячейке
спин-лок
удалить из списка новых записей
если элемент первый в списке, то обновить верхнюю границу чтения
спин-анлок

//TODO: А что если писатели начали писать раньше чтения
Чтение:
Проверяем границы на чтение
Если в границах на чтение:
	Читаем
спин-лок
Переходим на следующую позицию
Если старая позиция не нужна, удаляем её.
Если этот номер был первым, то удаляем первое сообщение (увеличиваем верхнюю границу)
Если следующей позиции нет, то создаём, добавляем куда надо для последующего быстрого поиска
спин-анлок

При записи пытаемся:
if (atomic_dec_if_positive(free_count) != -1) {
	spin_lock(buf->lock);
	addr = buf->end;
	if (buf->end == buf->base_end) {
		buf->end = buf->base_begin;
		inverse = ~inverse;
	} else {
		buf->end += buf->blk_size;
	}
	add_writer_position(write_queue, pub);
	spin_unlock(buf->lock);
	
} else {
	err = EAGAIN;
}

При чтении:

Высокоурвоневая версия записи:
if (lock_if_free_buffer(buf)) {
	addr = acquire_buf_blk();//возвращает end
	prohibit(prohibits, addr);
	unlock_buffer(buf);
	copy_from_user(addr, ...);
	lock_buffer(buf);
	unprohibit(prohibits, addr);
	unlock_buffer(buf);
} else {
	return -EAGAIN;
}
return err;

Высокоуровневая версия чтения:
addr = addr_of_pos(pos);
if (addr != NULL && !is_prohibited(addr)) {
	copy_to_user(addr, ...);
	spin_lock();
	disconnect_position(pos);
	if (is_not_used_pos) {
		pop_position_used();
		push_position_free();
	}
	if (!find_position(msgnum+1, pos)) {
		connect_position(pos);
	} else {
		find
		//Ну короче в коде не меняй
		push_positions_used()
	}
	spin_unlock();
} else {
	return -EAGAIN;
}
return err;

------------------------------------
Опять всё заново

Идея:
1)Убрать позиции в буфер
2)Позиции должны быть собраны в единый массив (чтобы избежать всяких утечек памяти)
3)Избавляемся от номеров
4)Подписчики, прочитавшие все сообщения, записываются на позицию "обновления" - это позиция, которая последняя в списке свободных
//TODO: А вот что делать, если пока подписчиков нет?

1)Изменить структуру буфер, добавить там массив позиций, занятных, свободных, пустую и позицию обновления добавить счетчик количества позиций
2)Добавить 

При подписке:
Если список используемых позиций не пустой:
	Подписываемся на первую позицию (connect)
Иначе
	Берем свободную позицию
	Устанавливаем её с указанием на buf.begin
	Подписываемся на неё
	Добавляем в список используемых позиций



При записи:
Буфер В буфере есть место?
	Запрети адрес в котором идёт запись
	Записывай в end
	Если у позиции "обновления" есть пользователи
		Перемести эту позицию в используемые
		Вставь этот адрес в позицию
	Освободи адрес, в котором шла запись
	Обнови end_read_num
Иначе если begin не занят позицией
	Удалить первое сообщение (то есть сместить begin на 1 блок)
	Запретить адрес в котором идёт запись
	Записать в end
	Если у позиции "обновления" есть пользователи
		Перемести эту позицию в используемые по адресу end (list_add_tail(used))
		Вставь этот адрес в позицию
	Разрешить адрес в котором шла запись
	Обнови end_read_num
Иначе
	Верни ошибку



При чтении:
Получаем у подписчика позицию
Если позиция - не позиция обновления:
	У позиции получаем адрес
	Узнаем адрес следующий позиции next_pos
	Отписываемся от позиции
	Если позиция без подписок:
		Перенести её в список свободных позиций
	Читаем
	Поиск новой позиции по новому адресу
	(Сначала соседней, если нет, то вставляем свободную)
	Если адрес = end_read, то установи update_pos = pos
Иначе:
	Верни ошибку





Итак, что я должен объяснить в РПЗ
Это аналитическая часть
1)Перехват функций, вся теоретическая база, включая kallsyms_lookup, register_kprobe, sys_call_table, где она может быть обнаружена
2)RW-семафоры, RCU, spin_lock
3)list, hash
4)Вернее, это должен быть 2)Что такое PubSub (подробное описание, возможно ещё раз придется перечитать и переделать)
5)copy_to_user, copy_from_user
6)Модель представления совместной памяти - напиши про vmalloc
Конструкторская часть
1)IDEF0 диаграмма (скорее всего она забанит, но посмотрим)
2)Схемы алгоритмов
3)Схема ПО
