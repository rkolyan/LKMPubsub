\documentclass{bmstu}

\begin{document}
	\makecourseworktitle
	{Информатика, искусственный интеллект и системы управления} % Название факультета
	{Программное обеспечение ЭВМ и информационные технологии} % Название кафедры
	{} %TODO: Тема работы
	{Головнев Н.В./ИУ7-74Б} % Номер группы/ФИО студента (если авторов несколько, их необходимо разделить запятой)
	{Рязанова Н.Ю.} % ФИО научного руководителя
	
\maketableofcontents
\chapter*{ВВЕДЕНИЕ}
\addcontentsline{toc}{chapter}{ВВЕДЕНИЕ}
Современные операционные системы, такие как Linux, предоставляют широкий спектр механизмов межпроцессного взаимодействия (IPC), включая pipes, сокеты, разделяемую память и сигналы. Однако в некоторых сценариях, особенно в высоконагруженных распределенных системах, традиционные методы IPC могут оказаться недостаточно гибкими или эффективными. Модель издатель-подписчик (PubSub) предлагает альтернативный подход, где процессы могут асинхронно обмениваться сообщениями через topics, что упрощает разработку и повышает масштабируемость системы.

Данный загружаемый модуль ядра расширяет функциональность Linux, добавляя новые системные вызовы, реализующие модель PubSub на уровне ядра. Это позволяет процессам взаимодействовать напрямую через ядро, минуя дополнительные уровни абстракции, что может значительно снизить накладные расходы и повысить производительность. Модуль предоставляет простой и эффективный интерфейс для регистрации издателей и подписчиков, публикации сообщений и их доставки заинтересованным сторонам.

Целью данной работы является создание механизма IPC, который бы соответствовал требованиям современных приложений, таких как высокочастотные торговые системы, IoT-платформы и распределенные вычисления, где низкая задержка и высокая пропускная способность критически важны. Внедрение PubSub на уровне ядра позволяет минимизировать задержки и обеспечить надежную доставку сообщений, что делает данный модуль полезным инструментом для разработчиков системного ПО.
%TODO: Ну и бред, сделай более нейтральным, потому что экспериментировать нет времени

\chapter{Аналитическая часть}
\section{Постановка задачи}
В соответствии с заданием на курсовую работу необходимо разработать загружаемый модуль ядра для добавления системных вызовов для межпроцессного взаимодействия по модели PubSub. Модуль должен предоставлять системные вызовы для создания и удаления топиков, регистрации и удаления процессов-издателей и процессов-подписчиков, отправки и получения данных.
Для решения поставленной задачи необходимо:
\begin{itemize}
	\item изучить модель межпроцессорного взаимодействия PubSub;
	\item изучить способы добавления новых системных вызовов через загружаемый модуль ядра;
	\item изучить средства синхронизации процессов, предоставляемых API ядра;
	%TODO: Ещё добавь варианты
	%TODO: Снизу измени эту парашу
	\item разработать алгоритмы и структуру программного обеспечения;
	\item исследовать разработанное программное обеспечение.
\end{itemize}

\section{Модель межпроцессорного взаимодействия PubSub}
Pubsub представляет из модель межпроцессорного взаимодействия, где получатель сообщения ("подписчик") и отправитель сообщений ("издатель") прикрепляются с соответствующей ролью к некоторому логическому узлу (топику), обладаемому некоторым уникальным идентификатором. Для того, чтобы процесс мог получать из топика сообщения, он должен быть зарегистрирован на нём как подписчик, а для того чтобы отправлять сообщения - как издатель. Процесс-издатель отправляет сообщение в топик, где сообщение хранится некоторое время, за которое процессы-подписчики могут его прочитать, затем сообщение удаляется. Данная модель не предоставляет никакие сведения процессам-подписчикам о процессах-издателях, в связи с чем сообщения от разных издателях могут передаваться поочередно.
%TODO: Надо написать исчерпывающее описание PubSub.

\section{Добавление системных вызовов}
В ядре Linux не предусмотрено добавление новых системных вызовов напрямую через загружаемый модуль ядра. Для того, чтобы осуществить добавление системного вызова, необходимо изучить принципы работы системного вызова.
%TODO: Проанализировать работу системных вызовов
%Типа, вот есть системные вызовы, которые вызываются при помощи ассемблерной инструкции syscall, которая
Работа системного вызова состоит из нескольких этапов:%TODO: Может использоваться int 8h
\begin{enumerate}
	\item Пользовательский процесс записывает в регистр RAX номер системного вызова, в регистры RDI, RSI, RDX, R10, R8, R9 аргументы системных вызовов.
	\item Далее вызывается ассемблерная инструкция syscall, которая сохраняет значение регистра RIP в RCX, сбрасывает флаг RF, сохраняет RFLAGS в R11, и загружает стек ядра (из MSR-регистров меняются регистры SS, CS, RIP и RFLAGS).
	\item Далее значения регистров сохраняются в структуру struct pt\_regs и осуществляется вызов do\_syscall\_64.
	\item Функция do\_syscall в свою очередь вызывает подфункции do\_syscall\_x64 и do\_syscall\_x32, которые, в свою очередь вызывают подфункции x64\_sys\_call и x32\_sys\_call соответственно. %TODO: Представить работу функций на listing
	\item В случае если по номеру системного вызова не было найдено обработчика, то вызывается функция \_\_x64\_sys\_ni\_syscall. %TODO: В нашем случае __ia32_sys_ni_syscall, в случае исходного кода sys_ni_syscall
\end{enumerate}

Таким образом, для того, чтобы добавить системный вызов, необходимо сделать перехват на одном из этих этапов. В данной работе рассмотрены способы перехвата sys\_ni\_syscall. %TODO:

\section{Методы перехвата функций ядра}
Существует несколько методов для перехвата функции в ядре Linux:
\begin{itemize}
	\item использование kprobe;
	\item использование ftrace;
	\item "модификация кода ядра на лету" (kernel live patching).
\end{itemize}

\subsection{Kprobes} %TODO: Возьми отсюда https://habr.com/ru/articles/413241/
Kprobes — это механизм ядра Linux, позволяющий перехватывать выполнение практически любой функции. Он используется для отладки, профилирования, мониторинга и даже модификации поведения ядра без его перезагрузки или перекомпиляции. Для его работы в ядре представлены структуры struct kprobe, устанавливающие пред- и пост-обработчики перехватываемой функции, и struct kretprobe, устанавливающей обработчик для перехвата возвращаемого значения функции. %TODO: Нужно описать функции для регистрации и удаления
Особенности использования Kprobes:
\begin{itemize}
	\item перехват любой инструкции осуществляется с помощью точек останова (ассемблерной инструкции \text{int3});
	\item функции-обработчики будут выполняться с отключением вытеснения, таким образом любые блокирующие процесс операции могут вызвать ошибку планирования;
\end{itemize}


\subsection{Ftrace}%TODO: Ссылки на
%TODO: Вот тут я вообще хз, что писать
\texttt{ftrace} \cite{ftrace} -- это фреймворк для трассировки ядра на уровне функций, реализованный на основе ключей компилятора \texttt{-pg} \cite{ftrace-habr} и \texttt{mfentry} \cite{ftrace-habr}. Данные функции вставляют в начало каждой функции вызов специальной трассировочной функции \texttt{mcount()} или \texttt{\_\_fentry()\_\_}. В пользовательских программах данная возможность компилятора используется профилировщиками, с целью отслеживания всех вызываемых функций. В ядре эти функции используются исключительно для реализации рассматриваемого фреймворка.

Для большинства современных архитектур процессора доступна оптимизация: динамический \texttt{frace} \cite{ftrace-habr}. Ядро знает расположение всех вызовов функций \texttt{mcount()} или \texttt{\_\_fentry()\_\_} и на ранних этапах загрузки ядра подменяет их машинный код на специальную машинную инструкцию \texttt{NOP} \cite{NOP}, которая ничего не делает. При включении трассировки, в нужные функции необходимые вызовы добавляются обратно. Если \texttt{ftrace} не используется, его влияние на производительность системы минимально.

Особенности рассматриваемого фреймворка:

\begin{itemize}
	\item многие функции ядра Linux могут быть перехвачены, в том числе x64\_sys\_call/ia32\_sys\_call, но перехватить функции \_\_ia32\_sys\_ni\_syscall/\_\_x64\_sys\_ni\_syscall при помощи ftrace нельзя;
	\item перехват совместим с трассировкой;
\end{itemize}

\subsection{Модификация кода ядра} %TODO: Хз как назвать
Модификация кода ядра подразумевает встраивание своего ассемблерного кода в защищённые от записи адреса ядра Linux. Для этого требуется найти нужный адрес в ядре, отключить защиту от записи (сбросить бит WP регистра CR0), записать по этому адресу новый машинный код и обратно установить бит WP регистра CR0.

Особенности такого подхода:
\begin{itemize}
	\item Машинный код архитектурно зависимый, поэтому для каждой отдельной архитектуры приходится писать разные машинные коды;
	\item Необходимо учитывать возможные состояния регистров и стека, изменения некоторых значений могут нарушить работу всей системы.
\end{itemize}
%TODO: модификация поведения?
Одной из методов модификации кода ядра является написание <<трамплинов>> (trampoline) - использование ассемблерных инструкций перехода jmp или call для вызова обработчика, которые добавляется через загружаемый модуль ядра. В данной работе будет рассмотрен перехват функции sys\_ni\_syscall с использованием трамплина.
%TODO: А нужно ли писать пример?

\section{Средства синхронизации процессов}
Ядро Linux предоствляет множество средств синхронизации, удобных для использования в конкретных ситуациях. Рассмотрим основные:
\begin{itemize}
	\item спинлоки;
	\item мьютексы;
	\item семафоры;
	\item RW-семафоры (Read/Write семафоры, семафоры <<читатели/писатели>>);
	\item RCU;
	\item атомарные (неделимые) операции.
\end{itemize}
Спинлок - примитив синхронизации, который осуществляет единичный доступ к ресурсу. Процесс, первый захвативший спин-лок, осуществляет работу в критической секции, остальные процессы, пытавшиеся захватить спинлок переходят в фазу активного ожидания и простаивают до тех пор, пока спин-лок не будет освобожден. Спинлоки представлены в ядре Linux типом spinlock\_t (struct spinlock). Для захвата и освобождения спинлока используются функции spin\_lock() и spin\_unlock() соответственно.%TODO: Покажи структуру
Мьютекс - примитив синхронизации, работает аналогично спинлоку, только вместо перевода в фазу активного ожидания блокирует процессы до тех пор, пока мьютекс не будет освобожден. В связи с этим не может быть использован в атомарном контексте или контексте прерывания. Представлен в ядре структурой struct mutex. %TODO: Надо показать структуру
%TODO: Семафор
RW-семафор - семафор, предназначенный для задач с частыми операциями чтения и редкими операциями записи. Он позволяет осуществить одновременный множественный доступ процессам-читателям, либо единичный доступ процессу-писателю. Ядро Linux в качестве RW-семафора предоставляет 2 структуры: struct rw\_semaphore и struct rwlock\_t. %TODO: Нужно бы ещё кратенько рассказать про очередь
RCU (Read-Copy-Update) - механизм синхронизации предназначенный для задач с частыми операциями чтения и редкими операциями записи. Основная идея такова: пусть есть некоторая редко изменяемая структура данных, процесс-писатель создает её копию, в которой записывает все изменения, в то время как процессы-читатели работают с первоначальной не изменяемой структурой. После того, как процесс-писатель заканчивает работу с копией, в некоторый безопасный момент времени, когда процессы-читатели не работают со структурой, первоначальная структура подменяется на измененную копию. %TODO: Хуйня переписывай
Читатели в технике RCU выполняются в критической секции чтения (read-side critical section). При входе в такую критическую секцию читатель вызывает функцию rcu\_read\_lock(), при выходе — rcu\_read\_unlock().Если поток находится не в критической секции чтения, то говорят, что поток в спокойном состоянии (quiescent state, quiescent-состояние). Любой период времени, в котором каждый поток хотя бы единожды находился в quiescent-состоянии, называют grace period. Каждая критическая секция чтения, которая началась перед grace period, должна закончиться прежде, чем закончится grace period.
%TODO: Нужен подробный анализ почему
%TODO:https://habr.com/ru/articles/206984/


\chapter{Конструкторская часть}
\section{Последовательность преобразований}
%TODO: IDEF0 нулевого уровня (А что там?)
В качестве управления - пользовательский процесс, в качестве механизма - системный вызов.
Входы - %TODO
Выходы - %TODO
\section{Обработка и хранение сообщений}
Для хранения сообщений для конкретного топика модели PubSub используется кольцевой буфер со списком позиций процессов-подписчиков и списком недоступных адресов. Буфер разделен на некоторое количество блоков, общее количество блоков и их размер определяется аргументами системного вызова для создания топика. Под позицией подразумевается структура, хранящая в себе адрес текущего блока из кольцевого буфера для четния и счётчик подписчиков, которые ещё не прочитали сообщение из указанного блока.
Кольцевой буфер имеет 5 указателей:base\_begin, base\_end, begin, end\_read, end. base\_begin и base\_end указывают на начальный и конечный адрес буфера. begin - указывает на начало очереди сообщений, end\_read - указывает на конец очереди для сообщений и является началом участка буфера, в которые записываются в текущий момент сообщения, end - указывает на конец этого участка. Список недоступных адресов хранит адреса, в которые производится в текущий момент запись сообщений. 
%TODO: IDEF0 первого уровня
%TODO: Схема алгоритма создания топика
%TODO: Схема алгоритма удаления топика
%TODO: Схема алгоритма добавления процесса-издателя
%TODO: Схема алгоритма удаления процесса-издателя
%TODO: Такие же алгоритмы, только для процесса-подписчика
%TODO: Схема отправки данных
%TODO: Схема получения данных


\chapter{Технологическая часть}
\section{Выбор языка и среды программирования}
Для реализации данного курсового проекта был использован язык программирования C стандарта C99, так как на этом языке написан код ядра операционной системы Linux. Для компиляции модуля был использован GNU Compiler Collection (GCC) - стандартный компилятор UNIX-подобных операционных систем. GCC интерпретирует аргументы командной строки, определяет и запускает для каждого входного файла встроенный компилятор C99, а также ассемблер и компоновщик.
Сборка модуля производится автоматически с помощью утилиты make.

\section{Функции для добавления и удаления новых системных вызовов}%TODO: Название функции
%TODO: Вот функция, которая записывает ассемблерную команду по адресу sys\_ni\_syscall,
%вот функция, которая находит свободные адреса
\section{Функции обработчики системных вызовов}
%TODO: topic_create, topic_delete и тд

\section{Используемые структуры}
%TODO: Вставь сюда структуры топика, издателя, подписчика, буфера и тд

\section{Функции для работы с разделяемой областью памяти}
%TODO: Структура для работы 

\chapter{Исследовательская часть}
%TODO: Для исследования работы системных вызовов были написаны программы запускаемые пользователями для 

\chapter{ЗАКЛЮЧЕНИЕ}
\end{document}
