\documentclass{bmstu}

\begin{document}
	\makecourseworktitle
	{Информатика, искусственный интеллект и системы управления} % Название факультета
	{Программное обеспечение ЭВМ и информационные технологии} % Название кафедры
	{} %TODO: Тема работы
	{Головнев Н.В./ИУ7-74Б} % Номер группы/ФИО студента (если авторов несколько, их необходимо разделить запятой)
	{Рязанова Н.Ю.} % ФИО научного руководителя
	
\maketableofcontents
\chapter*{ВВЕДЕНИЕ}
\addcontentsline{toc}{chapter}{ВВЕДЕНИЕ}
Современные операционные системы, такие как Linux, предоставляют широкий спектр механизмов межпроцессного взаимодействия (IPC), включая pipes, сокеты, разделяемую память и сигналы. Однако в некоторых сценариях, особенно в высоконагруженных распределенных системах, традиционные методы IPC могут оказаться недостаточно гибкими или эффективными. Модель издатель-подписчик (PubSub) предлагает альтернативный подход, где процессы могут асинхронно обмениваться сообщениями через topics, что упрощает разработку и повышает масштабируемость системы.

Данный загружаемый модуль ядра расширяет функциональность Linux, добавляя новые системные вызовы, реализующие модель PubSub на уровне ядра. Это позволяет процессам взаимодействовать напрямую через ядро, минуя дополнительные уровни абстракции, что может значительно снизить накладные расходы и повысить производительность. Модуль предоставляет простой и эффективный интерфейс для регистрации издателей и подписчиков, публикации сообщений и их доставки заинтересованным сторонам.

Целью данной работы является создание механизма IPC, который бы соответствовал требованиям современных приложений, таких как высокочастотные торговые системы, IoT-платформы и распределенные вычисления, где низкая задержка и высокая пропускная способность критически важны. Внедрение PubSub на уровне ядра позволяет минимизировать задержки и обеспечить надежную доставку сообщений, что делает данный модуль полезным инструментом для разработчиков системного ПО.
%TODO: Ну и бред, сделай более нейтральным, потому что экспериментировать нет времени

\chapter{Аналитическая часть}
\section{Постановка задачи}
В соответствии с заданием на курсовую работу необходимо разработать загружаемый модуль ядра для добавления системных вызовов для межпроцессного взаимодействия по модели PubSub. Модуль должен предоставлять системные вызовы для создания и удаления узлов, %TODO: или топиков?
 регистрации и удаления процессов-издателей и процессов-подписчиков, отправки и получения данных.
Для решения поставленной задачи необходимо:
\begin{itemize}
	\item изучить модель межпроцессорного взаимодействия "Издатель/Подписчик";
	\item изучить способы добавления новых системных вызовов через загружаемый модуль ядра;
	\item изучить средства синхронизации процессов, предоставляемых API ядра;
	%TODO: Ещё добавь варианты
	%TODO: Снизу измени эту парашу
	\item разработать алгоритмы и структуру программного обеспечения;
	\item исследовать разработанное программное обеспечение.
\end{itemize}

\section{Модель межпроцессорного взаимодействия <<Издатель/Подписчик>>}
Представляет из анонимную модель межпроцессорного взаимодействия, где получатель сообщения ("подписчик") и отправитель сообщений ("издатель") прикрепляются с соответствующей ролью к некоторому логическому узлу, обладаемый некоторым уникальным идентификатором - тегом. Для того, чтобы процесс мог получать из узла сообщения, он должен быть зарегистрирован на нём как подписчик, а для того чтобы отправлять сообщения - как издатель. Сообщения, отправленные на ...

Анонимная модель межпроцессорного взаимодействия.
Процессы-подписчики получают сообщения.
Процессы-издатели отправляют сообщения.
Обмен сообщений происходит через некоторый логический узел, на котором процессы регистрируются как издатели и подписчики. Каждый такой логический узел обладает своим уникальным идентификатором.
Сообщения, отправленные на этот логический узел, хранятся там некоторый заданный промежуток времени или до тех пор, пока последний начавший читать это сообщение в этот промежуток времени процесс-подписчик не закончит читать сообщение. После этого сообщение удаляется.
%TODO: Надо написать исчерпывающее описание PubSub.

\section{Добавление системных вызовов}
В ядре Linux не предусмотрено добавление новых системных вызовов напрямую через загружаемый модуль ядра. Для того, чтобы осуществить добавление системного вызова, необходимо изучить принципы работы системного вызова.
%TODO: Проанализировать работу системных вызовов
%Типа, вот есть системные вызовы, которые вызываются при помощи ассемблерной инструкции syscall, которая
Работа системного вызова состоит из нескольких этапов:%TODO: Может использоваться int 8h
\begin{enumerate}
	\item Пользовательский процесс записывает в регистр RAX номер системного вызова, в регистры RDI, RSI, RDX, R10, R8, R9 аргументы системных вызовов.
	\item Далее вызывается ассемблерная инструкция syscall, которая сохраняет значение регистра RIP в RCX, сбрасывает флаг RF, сохраняет RFLAGS в R11, и загружает стек ядра (из MSR-регистров меняются регистры SS, CS, RIP и RFLAGS).
	\item Далее значения регистров сохраняются в структуру struct pt\_regs и осуществляется вызов do\_syscall\_64.
	\item Функция do\_syscall в свою очередь вызывает подфункции do\_syscall\_x64 и do\_syscall\_x32, которые, в свою очередь вызывают подфункции x64\_sys\_call и x32\_sys\_call соответственно. %TODO: Представить работу функций на listing
	\item В случае если по номеру системного вызова не было найдено обработчика, то вызывается функция \_\_x64\_sys\_ni\_syscall. %TODO: В нашем случае __ia32_sys_ni_syscall, в случае исходного кода sys_ni_syscall
\end{enumerate}

Таким образом, для того, чтобы добавить системный вызов, необходимо перехватить вызов системного вызова на одном из этих этапов. В данной работе рассмотрены способы перехвата sys\_ni\_syscall. %TODO:

\section{Методы перехвата функций ядра}
Существует несколько методов для перехвата функции в ядре Linux:
\begin{itemize}
	\item использование kprobe;
	\item использование ftrace;
	\item "модификация кода ядра на лету" (kernel live patching).
\end{itemize}

\subsection{Kprobes}
Kprobes — это механизм ядра Linux, позволяющий перехватывать выполнение практически любой функции. Он используется для отладки, профилирования, мониторинга и даже модификации поведения ядра без его перезагрузки или перекомпиляции. Для его работы в ядре представлены структуры struct kprobe, устанавливающие пред- и пост-обработчики перехватываемой функции, и struct kretprobe, устанавливающей обработчик для перехвата возвращаемого значения функции. %TODO: Нужно описать функции для регистрации и удаления
Особенности использования Kprobes:
\begin{itemize}
	\item перехват любой инструкции осуществляется с помощью точек останова (ассемблерной инструкции \text{int3});
	\item функции-обработчики будут выполняться в атомарном контексте, таким образом любые блокирующие процесс операции могут вызвать ошибку планирования;
\end{itemize}

\subsection{Ftrace}
%TODO: Вот тут я вообще хз, что писать

\subsection{Kernel live patching} %TODO: Хз как назвать
Kernel live patching подразумевает встраивание своего ассемблерного кода в защищённые от записи адреса ядра Linux. Для этого требуется:
\begin{enumerate}
	\item Вычисление адресов перехватываемой функции и функции-обработчика;
	\item Отключение защиты страниц от записи (сброс флага WP в регистре CR0);
	\item Запись по адресу перехватываемой функции инструкции перехода (например, jmp);
	\item Включение защиты страниц от записи (установка флага WP в регистре CR0);
\end{enumerate}
%TODO: В данной работе задействован kprobe для поиска адреса функций по символьному имени + kernel live patching для перехвата

section{Методы }

\end{document}
