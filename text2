Что делает функция sys_execve?
int execve(const char *pathname, char *const argv[], char *const envp[]);

pathname - либо путь до исполняемого файла (/home/rkolyan/execfile), либо #!interpretor (например #!/bin/bash)
argv - аргументы командной строки
envp - переменные окружения (наподобие PATH=/usr/bin)

execve(filename, argv, envp) => 
doexecve(getname(filename), argv, envp) => 
{аргументы argv и envp заворачиваются в структуры user_arg_ptr и user_arg_ptr} => 
do_execveat_common(AT_FDCWD, filename, argv, envp, 0) => 
//AT_FDCWD - специальное значение (-100) Специальное значение для dirfd(?) используется для указания того, что openat должен использовать текущий рабочий каталог.
//0 - значение флагов (все сброшены)

Итак функция 
static int do_execveat_common(int fd, struct filename *filename,
			      struct user_arg_ptr argv,
			      struct user_arg_ptr envp,
			      int flags)
//rlimit - resource limit
1)Проверка корректности filename (названия файла)
//RLIMIT_NPROC - Максимальное количество процессов
2)Проверка флага текущего потока на превышение максимального количества процессов и следующая проверка:
a)проверка на превышение максимально допустимого числа запущенных процессов (rlim[RLIMIT_NRPOC] в структуре task_struct)
б)Хз что такое ucounts, но кажется это подразумевается количество пользователей, и походу тут просто проверяются лимиты у пользователей.
3)Установка флагов на отсутствие превышений ограничений по запускам процессов
4)Далее в области памяти размещаем структуру linux_binprm.
//TODO: alloc_bprm(fd, filename, flags) - Именно здесь открывается файл и инициализируется пользовательский контекст
в __bprm_mm_init и вычисляется bprm->p (я так понял это указатель на начало инструкций)
bprm_init:
	Размещает в памяти структуру mm_struct (mm_alloc)
	Устанавливает ограничение на стек из current->signal->rlim[RLIMIT_STACK];
__bprm_mm_init(bprm):
	Выделяем регион виртуальной памяти (vm_area_alloc) и добавляем его в список в mm_struct //TODO: Здесь тоже может быть интересно. Помечаем его как анонимный.
	Далее захватываем на текущей структуре lock.
	Вызывается ksm_execve.
Я так понял ksm
ksm_execve(mm):
	Проверяется бит MMF_VM_MERGE_ANY флагов mm_struct.
	Вызывается __ksm_enter(mm).
__ksm_enter(mm):
	Выделяется слаб под какой-то ksm_slot (смотри ниже)
	Этот слаб добавляет в хеш-таблицу (слаб имеет указатель на mm)
	Далее в зависмости от значения ksm_run определяется в какой список попадет ещё этот слот.
	Далее установка бита MMF_VM_MERGEABLE (?) в флаги mm
	Вызывается mmgrup(mm) (она "закрепляет" (pin) структуру), которая просто увеличивает атомарно mm_count;
	Далее, в случае блокировки поток "просыпается".
Возврат в __bprm_mm_init:
	Установка начала и конца VM (конец конст, начало = vm_end - PAGE_SIZE)
	Установка флагов vma (VM_SOFTDIRTY | VM_STACK_FLAGS | VM_STACK_INCOMPLETE_SETUP)
	Далее получение защиты страницы (?) (vm_get_page_prot, экспортируемая функция)
	Далее vma вставляется в список процесса(insert_vm_struct)
	Далее количество страниц = количество страниц под стек = 1
	Установка bprm->p ниже стека на 8 байт
Возврат в alloc_bprm
5)Далее вычисляются количество аргументов командной строки (argv), переменных окружения, вычисляются ограничения на программный (вроде) стек bpmn, (эти операции смещают значение bprm->p), копируется имя файла в bprm.
6)Вызывается bprm_execve
bprm_execve(bprm):
	Сначала подготавливаются значения creds (Права доступа и тд, они копируются из current) в bprm
	Затем определяется насколько безопасно выполнять предлагаемую программу (check_unsafe_exec). Внутри всё завязано на LSM
	Устанавливаем значение current->in_execve = 1;
	Вызывает sched_mm_cid_before_execve(current) я не очень понял, что она делает
	Далее вызывает sched_exec, что она делает я не понял, но походу занимается балансировкой нагрузки между CPU, это связано с тем, что процесс в текущем состоянии имеет наименьшую память и кэш (ну, то есть сейчас прям самое лучшее время).
	Далее установка неизменившейся части bprm->cred при помощи security_bprm_creds_for_exec (Там вроде просто какой-то хук делается)
	exec_binprm(bprm)//TODO:Там полный пиздец

/**
 * struct ksm_mm_slot - ksm information per mm that is being scanned
 * @slot: hash lookup from mm to mm_slot
 * @rmap_list: head for this mm_slot's singly-linked list of rmap_items
 */
struct ksm_mm_slot {
	struct mm_slot slot;
	struct ksm_rmap_item *rmap_list;
};
Функция sched_mm_cid_before_execve() в ядре Linux связана с механизмом идентификации контекста выполнения (CID, Context ID) в планировщике (scheduler). Она используется для управления идентификаторами контекста выполнения при выполнении системного вызова execve(), который заменяет текущий образ процесса новым образом программы.
Что такое Context ID (CID)?

CID — это уникальный идентификатор, который планировщик ядра Linux использует для отслеживания контекста выполнения задачи (процесса или потока). Он помогает планировщику оптимизировать выполнение задач, учитывая их контекст, например:
    Локальность данных (data locality).
    Историю выполнения (execution history).
    Привязку к ядрам CPU (CPU affinity).
Зачем нужна sched_mm_cid_before_execve()?
Когда процесс выполняет системный вызов execve(), его адресное пространство (mm_struct) заменяется новым. Это означает, что:
    Старый контекст выполнения (включая CID) становится недействительным.
    Новый образ программы требует нового контекста выполнения.
Функция sched_mm_cid_before_execve() вызывается перед выполнением execve(), чтобы:
    Сохранить или сбросить текущий CID.
    Подготовить планировщик к изменению контекста выполнения.
Как работает sched_mm_cid_before_execve()?
    Сброс CID
    Если процесс выполняет execve(), его текущий CID больше не актуален, так как новый образ программы может иметь совершенно другие характеристики выполнения. Функция сбрасывает CID, чтобы планировщик мог назначить новый идентификатор после завершения execve().
    Подготовка планировщика
    Функция уведомляет планировщик о том, что контекст выполнения задачи изменится. Это позволяет планировщику:
    Освободить ресурсы, связанные с текущим CID.
    Подготовиться к созданию нового CID для нового образа программы.
    Синхронизация
    Функция гарантирует, что изменение CID будет выполнено атомарно, чтобы избежать гонок (race conditions) при многопоточном выполнении.

Итог
sched_mm_cid_before_execve() — это вспомогательная функция, которая:
    Сбрасывает текущий CID перед выполнением execve().
    Подготавливает планировщик к изменению контекста выполнения.
    Обеспечивает корректную работу планировщика при замене образа процесса.
Этот механизм важен для оптимизации производительности и корректной работы планировщика в многозадачных системах.
