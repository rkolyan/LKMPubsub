Чтение сообщения
Есть структура sub
1. Получаем pos из sub (изменять pos у sub может только сам sub);
2. Узнаем номер pos (он может менятся у pos во время записи, например, когда первое сообщение удаляется, pos смещается на следующее)
3. По номеру происходит чтение из буфера (оно может затираться, то есть может происходить чтение во время записи)
---Если прочиталось--
4. Отписываем подпичика от позиции (уменьшаем её счётчик)
5. Если счётчик = 0
<----Между этими операцими какой-то подписчик мог подписаться, поэтому нужно поставить между ними защиту,
например
spin_lock(lock);
if (is_position_not_used(pos)) {
	block = 1;
	pop_used_position(pos);
}
spin_unlock(lock);
if (block) {
	продолжаем удаление
}
5.1 удаляем позицию (могут возникнуть проблемы при чтении, нужно использовать synchronize_rcu и спин-лок)
5.2 Добавляем новую позицию в свободные (там можно изпользовать kmem_cache_free)
5.3 Далее идет чтение с буфера. Что можно придумать с неделимыми переменными, чтоб запись и чтение не совпадающих номеров происходили одновременно?

6. Найденный номер увеличиваем
7. Находим по новому номеру новую позицию
<---------Вот здесь может произойти то, что позиция удаляется,
решаем также, используя ранее введенный spin_lock:
block = 0
spin_lock(lock);
err = find_msg_num_pos(...)
if (!err) {
	connect_subscriber_position(sub, pos);
	block = 1;
}
spin_unlock(lock)
if (block) {
	Продолжаем
}
8.1. Если нашли то подписчик переподписывается на выбранную позицию
<----Спинлок
8.2. Если не нашли то просматриваем следующую позицию
8.2.1 Если найдена берём свободную позицию (может отдельный спинлок использовать);
8.2.2.... Короче, там добавляем новый, присоединяем
<----Спин-анлок


Отправка сообщения
1. Проверка, что буфер полон
2. Тут те же самые операции, что и в receive_message_from_node, аналогичное использование спинлок

Буфер:
Чтение:
Делаем проще
1.Спин-лок
--Обновляем значение нижней "границы блокировки" - это будет атомарная переменная
2.Спин-анлок
Чтение данного блока
сброс атомарной переменной


Запись:
Спин-лок
--Обновляем данные в buf->end, buf->begin (если потребуется), end_num, begin_num(Если потребуется)
Спин-анлок
Просматриваем нижнюю границу чтения, если она равна записываемой, то ждём окончания блока снизу
(делаем это через atomic_sub_and_test)
Возможно здесь как-то можно сделать rcu, типа, rcu указывает на следующее значение массива при обращении чтения

Если у нас неблокируемый режим записи и если свободных полей нет



if (atomic_try_cmpxchg(end, base_end, base_begin)) {
	//Ставим блок на чтение этого адреса, или проверяем
	обновляем base_begin_num
} else {
	atomic_add(block_size);
}

Запись
Итак, получаем адрес сообщения, который надо написать
spin_lock()
//Увеличиваем номер сообщения (end_num)
//Увеличиваем указатель сообщения (end)
//Если указатель сообщения превысил границу, делаем инверсию флага (что теперь конец чтения раньше начала по адресу)
//Обновляем верхний ограничитель записи
spin_unlock()

//TODO: Проверка на границы чтения (может быть до спин-лока, тогда всем операциям записи нужно будет ждать, пока прочитается значение из буфера)
//TODO: Может быть после спинлока, тогда он может быть заблокирован на пограничном мьютексе может быть?
//TODO: В случае записи следующий может быть также заблокирован, тогда указатели будут увеличены и пойдет неправильная запись
 
//Далее идёт процесс записи в блок

spin_lock()
//Заканчиваем, помечаем, что блок доступен для чтения (Как это сделать?)
//В случае, если собственое число == нижней границы, то увеличиаем нижнюю границу
spin_unlock()

//TODO: Видимо, единственное что можно сделать это мьютекс на запись, когда записывается только 

Конец


Процесс чтения:
Пусть 




Алгоритмы быстрого неблокируемого чтения из буфера 
1)Определяем номер сообщения
2)Если номер в пределе, ставим минимальный номер в порядке следования с ним и ставим блок на этот номер
(только вот как этот блок поставить?)
3)atomic_fetchadd()



В случае с буфером можно использовать atomic_inc_return(end_num), atomic_inc_return(begin_num)
atomic_fetch_inc_acquire(end)
atomic_cmpxchg_relaxed_long(atomic_t *v, old, new) Если v == old, то v = new

можно сделать так

Поток проходит
atomic_
atomic_cmp

if (atomic_try_cmpxchg(end, base_end, base_begin)) {
	//записываем в base_begin
	обновляем base_begin
} else {
	
}


atomic_inc()

atomic_inc_return(end_num);


Запись:
Выделение структуры в кеше для того, чтобы писателя
Проверка свободности следующего блока (atomic_t rbegin)
Если следующий блок несвободен (то есть это первый блок на чтение):
	Если флаг блокировки не установлен:
		//TODO: Мы блокируем все записи и ждём, пока читатель дочитает
		устанвавливаем флаг, на удаление элемента чтения (чтоб будущие читатели не могли прочитать)
		захватываем мьютекс на первую запись
		//TODO: Но что если следующий тоже будет записывать, но уже не в этот свободный элемент, а следующий?
	Иначе:
		Переход на метку End
Иначе:
	Запись в этот блок
END:
Удаление структуры писателя из кеша

Чтение:
Создание элемента для чтения
Спинлок
Сравнение текущей позиции с началом чтения
Если позиция не первая, то установка флага на чтение
Спинанлок
Добавление элемента в список читателей
Начать чтение



можно использовать wait_event_interactible(wq_head, (int)wq_head->private) в записи.
В чтении wake_up_interruptible(wq_head). Заранее можно объявить глобальную переменную, которая хранит в себе номер текущей освобожденной от чтения позиции


Запись:
Если флаг блокировки не стоит:
	Смещаем позицию end
	Если читатель читает процесс
		Заблокировать писателя (отправить в очередь работ)
	Писатель в таблицу записываемых потоков ставит блок на позицию
	Писатель записывает данные
	Писатель удаляет блок на позицию в таблице

Чтение:
Если число за рамками чтения
	Вернуть сообщение об отказе (новых данных нет)
Пока позиция заблокирована и не выходит за рамки искать свободную ячейку (можно быстренько просмотреть список писателей и сразу же перейти на следующую)
Заблокировать позицию на чтение (например минимизация счётчика свободного элемента)
Произвести чтение
В случае, если текущая позиция заблокирована, то вызвать из отложенных работ функцию записи в этот элемент


